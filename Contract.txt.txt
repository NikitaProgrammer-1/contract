// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.7;

contract ShopManager {

     //Структура ролей в системе
    enum Role {
        BUYER,
        SELLER,
        SHOP,
        OWNER
    }
    Role currentRole;

    //Структура пользователей в системе
    struct User {
        string username;
        string shop;
        bytes32 passwordHash;
        bytes32 secretHash;
        Role maxRole;
        Role currentRole;
        bool exists;
    }

    //Структура магазина в системе
    struct Shop {
        string name;
        address owner;
        uint256 allowedToCapture;
        bool exists;
    }

    // Структура запроса роли
    struct ElevateRequest {
        address sender;
        Role role;
        string shop;
        bool exists;
    }   

    // структура ShopProductList (список продуктов в магазине, их цена и количество):
    //    string shop - название магазина
    //    products (id товара => информация о нём) - продукты в этом магазине и информация о них (цена, количество) по ID товара
    struct ShopProductList {
        string shop;
        mapping(uint256 => ShopProduct) products;
    }

    // структура ShopProduct - информация о товаре в конкретном магазине
    struct ShopProduct {
        uint256 id;
        uint256 price;
        uint256 amount;
        bool exists;
    }

    struct UserProducts{
        address user;
        mapping (string=>UserShopProducts) shops;
    }
    struct UserShopProducts{
        string shop;
        mapping(uint256 => UserOwnedProduct) products;
    }
    struct UserOwnedProduct {
        uint256 id;
        uint256 amount;
    }

    //Структура товара
    struct Product {
        uint256 id;
        string title;
        string description;
    }

    // Структура запроса на покупку товара
    struct BuyRequest {
        address author;
        uint256 productId;
        uint256 amount;
        string shop;
        bool accepted;
        bool reviewed;
        bool exists;
    }
    // Структура на возврат товара
    struct RefundRequest {
        uint256 id;
        uint256 buyRequestId;
        address author;
        bool reviewed;
        bool accepted;
        bool exists;
    }

    // Маппинг
    mapping (address =>UserProducts) userProducts;

    // Маппинг на возврать товара
     mapping(uint256 => RefundRequest) refundRequests;
    uint256[] refundRequestIds;

    // Маппинг на покупку товара
    mapping(uint256 => BuyRequest) BuyRequests;
    uint256[] buyRequestIds;

    // маппинг (название магазина => информация о продуктах в магазине)
    mapping(string => ShopProductList) shopProducts;

    // Маппинг и массив для работы со всеми структурами ПОЛЬЗОВАТЕЛЕЙ
    mapping(address => User) users;
    mapping(string => address) userLogins;
    string[] userLoginsArray;

    // Запросы на смену роли по пользователям
    mapping(address => ElevateRequest) elevReqs;
    address[] elevReqsArray;

     //Товары по магазинам
    mapping(uint256 => Product) products;
    uint256[] productIds;

    // Магазины
    mapping(string => Shop) shops;
    mapping(address => string) shopNamesByAddress;
    string[] shopCities;

     //Модификатор для работы функции, которую может запустить только владелец системы OWNER
    modifier onlyOwner() {
        require(users[msg.sender].currentRole == Role.OWNER, "Only can do it Owner!");
        _;
    }

    //Модификатор для работы функции, которую может запустить только продавец SELLER
    modifier onlySeller() {
        require(users[msg.sender].currentRole == Role.SELLER, "Only can do it Seller!");
        _;
    }

    modifier onlyShopSeller(string memory shopCity) {
        require(keccak256(abi.encodePacked(users[msg.sender].shop)) == keccak256(abi.encodePacked(shopCity)), "You have to be a seller in required shop");
        _;
    }

    modifier onlyShopOwner() {
        require(users[msg.sender].currentRole == Role.SHOP);
        _;
    }

    //Модификатор для работы функции, которую может запустить только продавец BUYER
    modifier onlyBuyer() {
        require(users[msg.sender].currentRole == Role.BUYER, "Only can do it Buyer!");
        _;
    }

    //Модификатор для работы функции, котоую может вызвать только покупатель и продавец BUYER и SELLER
    modifier onlySellerAndBuyer() {
        require(users[msg.sender].currentRole == Role.SELLER && users[msg.sender].currentRole == Role.BUYER, "Only can do it Seller and Buyer!");
        _;
    }


    // Функция добавления нового пользователя
    function createUser(
        address addr,
        string memory username,
        string memory passwordHash,
        string memory secretHash
    ) public {
        require(!users[addr].exists && !users[userLogins[username]].exists, "User already exist");

        userLoginsArray.push(username);
        userLogins[username] = addr;
        users[addr] = User(
            username,
            "",
            keccak256(abi.encodePacked(passwordHash)),
            keccak256(abi.encodePacked(secretHash)),
            Role.BUYER,
            Role.BUYER,
            true
        );
    }

    //Функцкия авторизации пользователя в системе 
    function authorizateUser(
        string memory username,
        string memory password,
        string memory secret
    ) public view returns (bool success) {
        User memory user = users[userLogins[username]];

        require(user.exists, "User does not exist");
        require(
            //encodePacked(password)) == user.passwordHash
            keccak256(abi.encodePacked(password)) == user.passwordHash && keccak256(abi.encodePacked(secret)) == user.secretHash,
            "Wrong password or secret"
        );

        return true;
    }

    //Функция запроса на смену роли
    function newElevateRequest(Role requiredRole, string memory requiredShop) public onlySellerAndBuyer returns(bool) {
        require(!elevReqs[msg.sender].exists, "You have already sent an elevate request!");

        elevReqs[msg.sender] = ElevateRequest(
            msg.sender,
            requiredRole,
            requiredShop,
            true
        );
        elevReqsArray.push(msg.sender);

        return true;
    }

    //Функция ввода нового администратора(только для администратора)
    function createNewOwner(
        address addr,
        string memory username,
        string memory passwordHash,
        string memory secretHash
    ) public onlyOwner {
        require(!users[addr].exists && !users[userLogins[username]].exists, "User already exist");

        userLoginsArray.push(username);
        userLogins[username] = addr;
        users[addr] = User(
            username,
            "",
            keccak256(abi.encodePacked(passwordHash)),
            keccak256(abi.encodePacked(secretHash)),
            Role.OWNER,
            Role.OWNER,
            true
        );
    }

     //Функция подтверждения заявки на повышение роли 
    function approveElevateRequest(address requestAuthor, bool accept) public onlyOwner {
        elevReqs[requestAuthor].exists = false;
        if(!accept) return;
    }

    //Функция отмены запроса на смену роли
    function cancelElevationRequest() public onlyOwner {
        require(
            elevReqs[msg.sender].exists,
            "You have not sent any elevate requests!"
        );

        elevReqs[msg.sender].exists = false;
        for (uint256 i = 0; i < elevReqsArray.length; i++) {
            if (elevReqsArray[i] == msg.sender) {
                delete elevReqsArray[i];
            }
        }
    }


//Функция создания заявки на покупку товара в магазине
    function buyProduct(string memory shop, uint256 productId, uint256 amount) public payable onlyBuyer returns(bool) {
        BuyRequests[buyRequestIds.length] = BuyRequest(
            msg.sender,
            productId,
            amount,
            shop,
            false,
            false,
            true 
        );

        ShopProduct memory product = shopProducts[shop].products[productId];
        require(product.exists, "This shop does not have this product");

        uint256 amountToPay = amount * product.price;
        require(msg.value == amountToPay, "You need to send exact amount of ether that is required to buy product");

        require(shopProducts[shop].products[productId].amount >= amount, "This shop does not have this item");
        shopProducts[shop].products[productId].amount -= amount;

        return true;
    }

    //Функция, которая возвращает информацию о товаре 
    function allInfoProduct(uint256 productId) public view returns(uint256 id, string memory title, string memory description) {
        return (productId, products[productId].title, products[productId].description);
    }

    //Функция, которая подтверждает покупку товара(подтвержает SELLER)
    function acceptedBuyProduct(uint256 requestId) public onlySeller returns(bool) {
        BuyRequests[requestId].reviewed = true;
        BuyRequests[requestId].accepted = true;
        BuyRequest memory buyRequest = BuyRequests[requestId];

        ShopProduct memory shopProduct = shopProducts[buyRequest.shop].products[buyRequest.productId];
        shops[buyRequest.shop].allowedToCapture += buyRequest.amount * shopProduct.price;
        userProducts[buyRequest.author].shops[buyRequest.shop].products[buyRequest.productId].amount += buyRequest.amount;

        return true;
    }
